
<link href="style.css" rel="stylesheet"></link>

#### <p style='text-align: right;'> 330 Computer Simulation - Project 2 Report<br/> Ziyi Zhang - zz2463<br/> April 27, 2020 </p>

***

### 1. Introduction
This project aims to simulate the traffic of an arbitrary graph and visualize the result with MATLAB. Any directed graph can be used as the input, and the simulation and visualization will be fully automated. Users can also control the details of the roads and nodes.

***

### 2. Equations and Numerical Methods
#### 2.1 Simulation of velocity
#### 2.1.1 Theoretical Equations
The velocity of any vehicle majorly depends on the distance to the car in the front
$$
v~ = ~
\begin{cases}
    0\text{,~~~~~~~~~~~~~~if $d$<$d_{min}$} \\
    v_{max} \text{,~~~~~~~~if $d$>$d_{max}$} \\
    v_{max}\cdot \log{\frac{d}{d_{min}}} / \log{\frac{d_{max}}{d_{min}}} \text{,~~otherwise}\\
\end{cases}
$$
where
- $d$ is the distance to the car in the front (if my car is the first on the current road, the last car on the next road will be used)
- $v_{max}$ is the speed limit. For most of the roads, the value is $80km/h$. For elevated highways, the value is $160km/h$.

There are cases where this equation does not hold, as explained in the next section 2.1.2.
#### 2.1.2 Numerical Methods
Normally, the location of a vehicle is updated based on
$$
\frac{loc(t+\Delta t)-loc(t)}{\Delta t} = \text{Velocity(d)}
$$
where "Velocity" is a function that implements the equation in 2.1.1.  
But there are a few cases where the location is not updated regularly, for example:
- If the car is near its destination and there is no car ahead, it will not accelerate. It should slow down.
- If there is a T-crossing road, straight traffic must go first. This turns out to have a significant influence on the simulation result.
#### 2.2 Path finding
Since the system accepts any directed graph, we need an efficient path-finding algorithm. A naive solution is to use Dijkstra for every car. But in order to accelerate the program, I used the Floyd algorithm to pre-calculate the route between any two nodes and all cars will look up this table when driving.
#### 2.2.1 Dynamic path finding
The problem with any shortest path algorithm is that it does not take congestion into account. All the traffic will flood in one road while another adjacent road is completely empty because it is a little "longer".  
In order to solve this problem, the program will take both traffic amount and road length into consideration to find the fastest (not shortest) path. The Floyd table will be updated every second such that the fastest path is changing in accordance to the real-time road condition.  
There is an example to illustrate this.

***

### 3. Visualization Interpretation
Take a simple cross-square graph as an example:
- There are four nodes and eight lanes in this map
- **Nodes** are represented as circles. Gray circles stand for small nodes and orange circles stand for mega-nodes. There is really no difference between them. It is only used in visualization to help users see which nodes are more important.
- There are also "pseudo-nodes" not shown here for special reasons. But let's keep this report simple.
- **Paths** are directed. I am using gradual colors to plot them. Cars can only drive from the black end to the orange end. If there is a bi-directional road between two nodes, two paths will be plotted.
- **Cars** are those small dots. The color indicates the speed. The faster a car goes, the warmer the color will be. 
- Sometimes you may notice a lot of dots crowded in one node (upper-left node in the following figure). **This is not a bug**. They are generated by this node but the road is so crowded that they cannot even leave this node. Think it as, this node is a community where some residents want to go to the supermarket, but they found the road has been full of cars and they can't even drive onto the main road! Those drivers soon get impatient and are moving crazily in that node. 
![ff](1.png)

***

### 4. Tests
To make sure the program is correctly coded, I designed a few simple graphs to test the simulation and visualization system.
The simulation went well as we speculated.
I tried to change simulation step $\Delta t$ in different scales and the result is quite stable. **This step has been repeated for all coming test cases.**

Only one example of the tests is shown here. But there are many more, and you can run them on your own PC.
#### 4.1 Intelligent path finding
In the following example, only the upper node is generating cars and the destination is always the lower node. It is generating so many cars that the traffic exceeds the capacity of one road. You will see some cars start to pass by the third node (the one on the left) when the shortest path is too crowded.  
This is hard to illustrate using screenshots. But it is quite obvious in the movie.
![ff](2.png)

***

### 5. Results
Tata... Here comes the highlight of this project. I spent several hours designing a small city with this system! I want to see whether building a circular elevated highway around the city will solve the congestion problem in the city center.
#### 5.1 The city
There are three central nodes (orange) and fifteen small nodes in the city.  
Around three-quarter of the traffic is moving between those three central nodes. But there will also be traffic coming from small nodes or even rural areas (bottom right nodes). Occasionally, people also want to go to rural areas. 
![ff](3.PNG)
You can see from the map that there is no direct road connecting the central nodes, so the cars will dynamiclly find the fastest path and such paths are changing when time flows.

#### 5.2 Traffic without elevated highways


***

### 6. Reference
- (1) Matthew Harker, Paul O'Leary, (2020). Surface Reconstruction from Gradient Fields: grad2Surf Version 1.0 (https://www.mathworks.com/matlabcentral/fileexchange/43149-surface-reconstruction-from-gradient-fields-grad2surf-version-1-0), MATLAB Central File Exchange. Retrieved March 13, 2020.
- (2) Víctor Martínez-Cagigal (2020). Whitish Jet Colormap (https://www.mathworks.com/matlabcentral/fileexchange/67415-whitish-jet-colormap), MATLAB Central File Exchange. Retrieved March 14, 2020.

***

### Appendix A How to run the code
You can run the code in real time, with any setup. No need to wait for a long time to create a movie. This is achieved by splitting the project into two parts:
- part A: SpringSimulation.m that does all simulation and stores the data into a mat file. It can be configured to disable all visual output for speed consideration.
- part B: GravityField.m that reads the mat file and calculate 2D and 3D visualization. It supports 'fast forward'.

To be more specific, to run 'stable' setup:
```{MATLAB}
>> RunSpringStable  % a script of variables for 'stable'
>> filename = 'stable'; SaveData
>> GravityField('stable')  % start the movie
```

Replacing three appearances of 'stable' by 'harmonic', 'tribody' or 'square' will run the corresponding script.  
You can also create your own 'RunSpringXXX' script with arbitary setup to play around with the system. 

***

### Appendix B SpringSimulation.m
```Matlab
%% spring system simulation
% The main script to run simulation
% Use 'GravityField' to visualize the gravity field after running this
% simulation

%{
% visualization parameters
c = [0, 0, 1;
     0.4, 0.8, 0.5;
     0.8, 0, 0.5;
     0.9, 0.4, 0];
dequeSize = 150;
XHist = ones(N, dequeSize) .* L(1, :)';
YHist = ones(N, dequeSize) .* L(2, :)';
dequePtr = 1; % deque to show trace
%{

%}
axisXMin = -1.5 * max(L, [], 'all');
axisXMax =  1.5 * max(L, [], 'all');
axisYMin = -1.5 * max(L, [], 'all');
axisYMax =  1.5 * max(L, [], 'all');
fieldResolution = 50;
axisXSpace = (axisXMax - axisXMin) / (fieldResolution-1);
axisYSpace = (axisYMax - axisYMin) / (fieldResolution-1);
[surfX, surfY] = meshgrid(axisXMin:axisXSpace:axisXMax, axisYMax:-axisYSpace:axisYMin);
% graphics output
set(gcf, 'double', 'on')
subplot(1, 2, 1)
hold on
h = scatter(L(1, :), L(2, :), 25.*ones(1, N), c(1:N, :), 'filled');
for i = 1:N
    htrail(i) = plot(XHist(i, :), YHist(i, :), 'Color', c(i, :));
end
hold off
subplot(1, 2, 2)
hold on
hfield = surf(surfX, surfY, zeros(length(surfX), length(surfY)), 'FaceColor', 'flat', 'EdgeAlpha', 0.1);
for i = 1:N
    hfieldmass(i) = scatter3(L(1, i), L(2, i), 0, 40, c(i, :), 'filled', 'MarkerEdgeColor', 'b');
end
hold off
view(3)
%}
%
%% Check validity of input
A = logical(A);
assert(nnz(V(:, A)) == 0);  % anchor points must have velocity zero
assert(size(Spring, 2) == 4);
assert(nnz(M<=0) == 0);
for i = 1:size(Spring, 1)
    assert(~( A(Spring(i, 1)) && A(Spring(i, 2)) ));  % should not have string connecting two anchor points
end

%% visualization
% spring color
cSpringConst = 55;
cSpring = whitejet(cSpringConst);
if visRealtime
    
    % marker color
    cMarker = colorcube;
    s = RandStream('mt19937ar','Seed',0);
    RandStream.setGlobalStream(s);
    idx = randperm(size(cMarker, 1));
    cMarker = cMarker(idx, :);
    cMarker = [lines(7); cMarker];
    % size
    mSize = calcSize(M);
    % trail deque
    Xtrail = ones(N, dequeSize) .* L(1, :)';
    Ytrail = ones(N, dequeSize) .* L(2, :)';
    dequePtr = 1; % deque to show trace
    % figrue
    figure('Position', [1739 50 1600 900])
    hold on
    set(gcf, 'double', 'on');
    % plot anchor and normal points
    for i = 1:N
        if A(i)
            h(i) = scatter(L(1, i), L(2, i), mSize(i)+10, 's', 'MarkerFaceColor', cMarker(i, :),...
                        'MarkerEdgeColor', 'black', 'LineWidth', 2);
        else
            h(i) = scatter(L(1, i), L(2, i), mSize(i), 'o', 'MarkerFaceColor', cMarker(i, :), 'MarkerEdgeColor', 'none');
            htrail(i) = plot(Xtrail(i, :), Ytrail(i, :), 'Color', cMarker(i, :));
        end
    end
    % plot springs
    for i = 1:size(Spring, 1)
        hspr(i) = plot(L(1, [Spring(i, 1), Spring(i, 2)]), L(2, [Spring(i, 1), Spring(i, 2)]),...
                      '-.', 'Marker', 'none', 'LineWidth', 1.5);
    end
    axis equal
    hold off
    % color bar
    %{
    colormap(cSpring);
    caxis([-9 9]);
    cbar = colorbar;
    cbar.Label.String = 'String force from compression to extension';
    %}
    % axis lim
    halfLength = max([max(L(1, :))-min(L(1, :)), max(L(2, :))-min(L(2, :))]);
    if halfLength<5, halfLength=5;end
    axisXMin = -halfLength*1.5;
    axisXMax = halfLength*1.5;
    axisYMin = -halfLength*1.5;
    axisYMax = halfLength*1.5;
end

if storeData
    
    XHist = zeros(N, clockmax);
    YHist = zeros(N, clockmax);
    colorSprIdx = zeros(size(Spring, 1), clockmax);
end

%% simulation starts here
count = 1;
for clock = 1:clockmax

    t = clock * dt;
    F = calcF(L, Spring);
    % now updating the velocity of i-th object
    for i = 1:N

        if A(i), continue;end  % skip anchor
        a = zeros(2, 1);
        for j = 1:N
            if i==j, continue;end  % divide by 0
            a = a + F(i, j) .* (L(:, j)-L(:, i)) ./ norm(L(:, i)-L(:, j));
        end
        a = a ./ M(i);

        % update velocity
        V(:, i) = V(:, i) + a .* dt;
    end
    % updating the location of i-th object
    L = L + V .* dt;

    % update realtime figrue
    if visRealtime
        for i = 1:N
            if A(i), continue;end
            set(h(i), 'xdata', L(1, i), 'ydata', L(2, i));
        end

        Xtrail(:, dequePtr) = L(1, :)';
        Ytrail(:, dequePtr) = L(2, :)';
        dequePtr = dequePtr + 1;
        if (dequePtr > dequeSize), dequePtr = 1;end
        for i = 1:N
            if A(i), continue;end
            set(htrail(i), 'xdata', [Xtrail(i, dequePtr:dequeSize), Xtrail(i, 1:dequePtr-1)],...
                           'ydata', [Ytrail(i, dequePtr:dequeSize), Ytrail(i, 1:dequePtr-1)]);
        end
    end
    % update spring, update spring color
    for i = 1:size(Spring, 1)
        dev = ceil(abs(3*F(Spring(i, 1), Spring(i, 2))));
        if dev>27, dev=27;end
        if F(Spring(i, 1), Spring(i, 2))>0
            color = cSpring(28+dev, :);
            if storeData, colorSprIdx(i, clock)=28+dev;end
        else
            color = cSpring(28-dev, :);
            if storeData, colorSprIdx(i, clock)=28-dev;end
        end
        if visRealtime
            set(hspr(i), 'xdata', L(1, [Spring(i, 1), Spring(i, 2)]),...
                         'ydata', L(2, [Spring(i, 1), Spring(i, 2)]),...
                         'Color', color);
        end
    end
    if visRealtime
        % drawnow
        drawnow
        xlim([axisXMin, axisXMax]);
        ylim([axisYMin, axisYMax]);
        pause(pauseTime);
    end
    % store data
    if storeData
        XHist(:, clock) = L(1, :)';
        YHist(:, clock) = L(2, :)';
    end
    % replot subimage-2
    %{
    gradient_ = zeros(fieldResolution, fieldResolution, 2);
    XArr = axisXMin:axisXSpace:axisXMax;
    YArr = axisYMax:-axisYSpace:axisYMin;
    for i = 1:length(XArr)
        for j = 1:length(YArr)
            for k = 1:N % for point (i, j) calc k-th planet's force

                p = [XArr(j); YArr(i)]; % position of probe
                r = norm(L(:, k) - p);
                gradient_(i, j, 1) = gradient_(i, j, 1) + 1 * (r - R0_) * (L(1, k) - p(1)) / r;
                gradient_(i, j, 2) = gradient_(i, j, 2) + 1 * (r - R0_) * (L(2, k) - p(2)) / r;
            end
        end
    end
    Z = -g2s(gradient_(:,:,1), gradient_(:,:,2), XArr', YArr');
    ZMax = quantile(Z(:), 0.95);
    Z(Z>ZMax) = ZMax;
    ZMin = quantile(Z(:), 0.05);
    Z(Z<ZMin) = ZMin;
    set(hfield, 'zdata', Z); % update field
    massZ = calcZ(Z, L, XArr, YArr);
    for i = 1:N
        set(hfieldmass(i), 'xdata', L(1, i), 'ydata', L(2, i), 'zdata', massZ(i));
    end
    %}
    if ~visRealtime
        if count > 500
            fprintf('%.2f\n', clock/clockmax);
            count = 0;
        end
        count = count + 1;
    end
end

%%
function [F] = calcF(L, Spring)

    N = size(L, 2);
    F = zeros(N, N);
    for i = 1:size(Spring, 1)
        f = Spring(i, 4) * (norm(L(:, Spring(i, 1))-L(:, Spring(i, 2))) - Spring(i, 3));
        F(Spring(i, 1), Spring(i, 2)) = f;
        F(Spring(i, 2), Spring(i, 1)) = f;
    end
end


function [mSize] = calcSize(M)

    low = 32;
    high = 90;
    minM = min(M);
    mSize = low .* (M ./ minM);
    mSize(mSize > high) = high;
end


function [massZ] = calcZ(Z, L, XArr, YArr)
    
    massZ = zeros(1, size(L, 2));
    for i = 1:size(L, 2)
        xx = 1;
        yy = 1;
        for j = 1:length(XArr)
            if XArr(j)>L(1, i)
               xx = j;
               break;
            end
        end
        for j = 1:length(YArr)
            if YArr(j)<L(2, i)
               yy = j;
               break;
            end
        end
        massZ(i) = Z(yy, xx) + 0.2;
    end
end
```

***

### Appendix C GravityField
```Matlab
function [] = GravityField(filename, focusIdx, fastForward)
% Visualize the gravity field based on the stored data
% 'filename' should be a 'mat' file created by 'SaveData.m'

    if nargin<2
        if strcmp(filename, 'harmonic'), focusIdx=2;fastForward=4;end
        if strcmp(filename, 'tribody'), focusIdx=1;fastForward=4;end
        if strcmp(filename, 'square'), focusIdx=1;fastForward=4;end
        if strcmp(filename, 'stable'), focusIdx=1;fastForward=30;end
    end
    %% read in data
    fprintf('Loading file <%s> with focus point index %d.\n', filename, focusIdx);
    data = load(filename);
    data = data.data;
    M = data.M;
    L = data.L;
    V = data.V;
    A = data.A;
    N = length(M);
    Spring = data.Spring;
    colorSprIdx = data.colorSprIdx;
    tmax = data.tmax;
    clockmax = data.clockmax;
    dt = tmax / clockmax;
    if ~isfield(data, 'XHist') || ~isfield(data, 'YHist')
        warning('Please run simulation before running this script.');
        return;
    end
    XHist = data.XHist;
    YHist = data.YHist;
    % fastForward
    idx = 1:fastForward:clockmax;
    clockmax = length(idx);
    XHist = XHist(:, idx);
    YHist = YHist(:, idx);
    colorSprIdx = colorSprIdx(:, idx);
    
    %% visRealtime
    % marker color
    cMarker = colorcube;
    s = RandStream('mt19937ar','Seed',0);
    RandStream.setGlobalStream(s);
    idx = randperm(size(cMarker, 1));
    cMarker = cMarker(idx, :);
    cMarker = [lines(7); cMarker];
    % spring color
    cSpringConst = 55;
    cSpring = whitejet(cSpringConst);
    % size
    mSize = calcSize(M);
    % trail deque
    dequeSize = 600;
    if strcmp(filename, 'harmonic')
        dequeSize = 1;
    elseif strcmp(filename, 'tribody')
        dequeSize = 200;
    elseif strcmp(filename, 'stable')
        dequeSize = 200;
    end
    Xtrail = ones(N, dequeSize) .* L(1, :)';
    Ytrail = ones(N, dequeSize) .* L(2, :)';
    % figrue
    figure('Position', [1739 50 1600 900])
    set(gcf, 'double', 'on');
    leftPanel = subplot(1, 2, 1);
    hold on
    % plot anchor and normal points
    for i = 1:N
        if A(i)
            h(i) = scatter(leftPanel, L(1, i), L(2, i), mSize(i)+10, 's', 'MarkerFaceColor', cMarker(i, :),...
                        'MarkerEdgeColor', 'black', 'LineWidth', 2);
        else
            h(i) = scatter(leftPanel, L(1, i), L(2, i), mSize(i), 'o', 'MarkerFaceColor', cMarker(i, :), 'MarkerEdgeColor', 'none');
            htrail(i) = plot(leftPanel, Xtrail(i, :), Ytrail(i, :), 'Color', cMarker(i, :));
        end
    end
    % plot springs
    for i = 1:size(Spring, 1)
        hspr(i) = plot(leftPanel, L(1, [Spring(i, 1), Spring(i, 2)]), L(2, [Spring(i, 1), Spring(i, 2)]),...
                      '-.', 'Marker', 'none', 'LineWidth', 1.5);
    end
    axis equal
    hold off
    % color bar
    cmap = colormap(leftPanel, cSpring);
    caxis(leftPanel, [-9 9]);
    caxis(leftPanel, 'manual');
    cbar = colorbar();
    cbar.Label.String = 'String force from compression to extension';
    cbar.Label.FontSize = 15;
    % axis lim
    halfLength = max([max(XHist, [], 'all')-min(XHist, [], 'all'), max(YHist, [], 'all')-min(YHist, [], 'all')]);
    if halfLength<5, halfLength=5;end
    axisXMin = -halfLength*1.1;
    axisXMax = halfLength*1.1;
    axisYMin = -halfLength*1.1;
    axisYMax = halfLength*1.1;
    if strcmp(filename, 'harmonic')
        axisXMin=-2;axisXMax=20;axisYMin=-7;axisYMax=7;
    elseif strcmp(filename, 'tribody')
        axisXMin=-10;axisXMax=17;axisYMin=-8;axisYMax=8;
    elseif strcmp(filename, 'square')
        axisXMin=-20;axisXMax=20;axisYMin=-20;axisYMax=20;
    elseif strcmp(filename, 'stable')
        axisXMin=-22;axisXMax=22;axisYMin=-22;axisYMax=22;
    end
    xlim(leftPanel, [axisXMin, axisXMax]);
    ylim(leftPanel, [axisYMin, axisYMax]);

    %% Gravity Field
    % springFocus to accelerate
    SpringFocus = [];
    SpringFocusConnected = false(N, 1);
    SpringFocusConnected(focusIdx) = true;
    for i = 1:size(Spring, 1)
        if Spring(i, 1)==focusIdx
            SpringFocus = [SpringFocus; Spring(i, 2:4)];  %#ok
            SpringFocusConnected(Spring(i, 2)) = true;
        end
        if Spring(i, 2)==focusIdx
            SpringFocus = [SpringFocus; Spring(i, 1), Spring(i, 3:4)];  %#ok
            SpringFocusConnected(Spring(i, 1)) = true;
        end
    end
    % plot hfieldmass
    fieldResolution = 50;
    axisXSpace = (axisXMax - axisXMin) / (fieldResolution-1);
    axisYSpace = (axisYMax - axisYMin) / (fieldResolution-1);
    [surfX, surfY] = meshgrid(axisXMin:axisXSpace:axisXMax, axisYMax:-axisYSpace:axisYMin);
    rightPanel = subplot(1, 2, 2);
    hold on
    hfield = surf(rightPanel, surfX, surfY, zeros(length(surfX), length(surfY)), 'FaceColor', 'flat', 'EdgeAlpha', 0.1);
    for i = 1:N
        if ~SpringFocusConnected(i), continue;end  % only plot connected masses
        hfieldmass(i) = scatter3(rightPanel, L(1, i), L(2, i), 0, 40, cMarker(i, :), 'filled', 'MarkerEdgeColor', 'b');
    end
    % legend
    fakeTarget = scatter3(rightPanel, 0, 0, -200, 2, cMarker(focusIdx, :), 'filled');
    legend_ = legend(fakeTarget, 'Surface reconstructed using this mass');
    legend_.FontSize = 15;
    legend_.AutoUpdate = false;
    % done
    grid on
    hold off
    view(3)
    force = zeros(fieldResolution, fieldResolution, 2);
    XArr = axisXMin:axisXSpace:axisXMax;
    YArr = axisYMax:-axisYSpace:axisYMin;
    xlim(rightPanel, [axisXMin, axisXMax]);
    ylim(rightPanel, [axisYMin, axisYMax]);
    zlimMin = -100;
    zlimMax = 100;
    if strcmp(filename, 'harmonic')
        zlimMin = -30;zlimMax = 40;
    elseif strcmp(filename, 'tribody')
        zlimMin = -100;zlimMax = 150;
    elseif strcmp(filename, 'square')
        zlimMin = -150;zlimMax = 50;
    elseif strcmp(filename, 'stable')
        zlimMin = -3e5;zlimMax = 4.5e5;
    end
    zlim(rightPanel, [zlimMin, zlimMax]);
    massZCorrection = 0.01 * (zlimMax - zlimMin);

    % pauseTime/FPS control
    pauseTime = 0.0;

    %% Start Animation
    for t = 1:clockmax
        pause(pauseTime);
        %% Left Panel
        % update points
        for i = 1:N
            if A(i), continue;end
            set(h(i), 'xdata', XHist(i, t), 'ydata', YHist(i, t));
        end

        for i = 1:N
            if A(i), continue;end
            idxStart = t-dequeSize;
            if idxStart<1, idxStart=1;end
            set(htrail(i), 'xdata', XHist(i, idxStart:t),...
                           'ydata', YHist(i, idxStart:t));
        end
        % update spring, update spring color
        for i = 1:size(Spring, 1)
            set(hspr(i), 'xdata', XHist([Spring(i, 1), Spring(i, 2)], t),...
                         'ydata', YHist([Spring(i, 1), Spring(i, 2)], t),...
                         'Color', cSpring(colorSprIdx(i, t), :));
        end
        %% Right Panel
        force = zeros(fieldResolution, fieldResolution, 2);
        for i = 1:length(YArr)
            for j = 1:length(XArr)
                for k = 1:size(SpringFocus, 1)

                    p = [XArr(j); YArr(i)];  % position of probe
                    k_ = SpringFocus(k, 1);  % idx of connected point
                    Lk_ = [XHist(k_, t); YHist(k_, t)];  % location of k_
                    r = norm([XHist(k_, t); YHist(k_, t)] - p);
                    forceElement = SpringFocus(k, 3) .* (r - SpringFocus(k, 2)) .* (Lk_ - p) ./ r;
                    force(i, j, 1) = force(i, j, 1) + forceElement(1);
                    force(i, j, 2) = force(i, j, 2) + forceElement(2);
                end
            end
        end
        force = toSmooth(force);
        Z = -g2s(force(:,:,1), force(:,:,2), XArr', YArr');

        Z(Z>zlimMax) = zlimMax;
        Z(Z<zlimMin) = zlimMin;
        
        set(hfield, 'zdata', Z); % update field
        massZ = interp2(surfX, surfY, Z, XHist(:, t), YHist(:, t));
        for i = 1:N
            if ~SpringFocusConnected(i), continue;end
            set(hfieldmass(i), 'xdata', XHist(i, t), 'ydata', YHist(i, t), 'zdata', massZ(i)+massZCorrection);
        end
        
        %% update figure
        drawnow
    end
end


%%
function [mSize] = calcSize(M)

    low = 32;
    high = 90;
    minM = min(M);
    mSize = low .* (M ./ minM);
    mSize(mSize > high) = high;
end


function [force] = toSmooth(force)
    
    forceAbs = abs(force);
    forceMax = quantile(forceAbs(:), 0.98);
    force(force>forceMax) = forceMax;
    force(force<-forceMax) = -forceMax;
end


function [massZ] = calcZ(Z, L, XArr, YArr)
    
    massZ = zeros(1, size(L, 2));
    for i = 1:size(L, 2)
        xx = 1;
        yy = 1;
        for j = 1:length(XArr)
            if XArr(j)>L(1, i)
               xx = j;
               break;
            end
        end
        for j = 1:length(YArr)
            if YArr(j)<L(2, i)
               yy = j;
               break;
            end
        end
        massZ(i) = Z(yy, xx) + 0.2;
    end
end
```
